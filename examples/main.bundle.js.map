{"version":3,"sources":["webpack:///main.bundle.js","webpack:///webpack/bootstrap 25ceab3b366187455a51?555b*","webpack:///./index.js","webpack:///../~/director/build/director.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p",0,"_director","routes","/classic","console","log","/filebrowser","router","Router","init",30,"dlocHashEmpty","dloc","hash","_every","arr","iterator","i","length","_flatten","flat","n","concat","_asyncEverySeries","callback","completed","iterate","err","paramifyString","str","params","mod","param","hasOwnProperty","regifyString","matches","last","out","substr","match","index","replace","capture","captures","slice","terminator","delimiter","start","stop","left","right","toString","chunk","indexOf","tmp","join","document","location","listener","mode","history","check","h","this","onHashChanged","fire","window","onpopstate","onhashchange","fn","onchange","onChangeEvent","l","listeners","self","undefined","documentMode","setTimeout","frame","createElement","style","display","body","appendChild","writeFrame","attachEvent","event","propertyName","setInterval","push","destroy","splice","setHash","s","pushState","title","f","getElementById","d","contentDocument","contentWindow","open","write","close","syncHash","_hash","methods","scope","_methods","_insert","insert","insertEx","historySupport","configure","mount","prototype","r","routeTo","handler","newURL","url","getPath","dispatch","charAt","convert_hash_in_init","replaceState","run_in_init","explode","v","split","setRoute","val","method","path","route","parent","once","apply","arguments","getRoute","ret","pathname","QUERY_SEPARATOR","options","recurse","async","strict","notfound","resource","html5history","run_handler_in_init","every","after","before","on","token","matcher","compiled","RegExp","source","Array","isArray","forEach","toLowerCase","routesFn","updateAndInvoke","fns","invoke","runlist","traverse","invoked","_invoked","reverse","thisArg","next","regexp","filter","filterRoutes","deepCopy","result","applyFilter","newRoutes","matched","current","exact","Boolean","methodType","parentType","nested","part","shift","test","Error","extend","extra","len","insertOrMount","local","rename","parts","routeType","isRoute"],"mappings":"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","file":"main.bundle.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ 0:\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _director = __webpack_require__(30);\n\t\n\tvar routes = {\n\t    '/classic': function classic() {\n\t        console.log('classic');\n\t    },\n\t    '/filebrowser': function filebrowser() {\n\t        console.log('filebrowser');\n\t    }\n\t};\n\t\n\tvar router = (0, _director.Router)(routes);\n\trouter.init();\n\n/***/ },\n\n/***/ 30:\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\t//\n\t// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n\t// Version 1.2.6\n\t//\n\t\n\t(function (exports) {\n\t\n\t/*\n\t * browser.js: Browser specific functionality for director.\n\t *\n\t * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n\t * MIT LICENSE\n\t *\n\t */\n\t\n\tvar dloc = document.location;\n\t\n\tfunction dlocHashEmpty() {\n\t  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n\t  // assumes both mean empty.\n\t  return dloc.hash === '' || dloc.hash === '#';\n\t}\n\t\n\tvar listener = {\n\t  mode: 'modern',\n\t  hash: dloc.hash,\n\t  history: false,\n\t\n\t  check: function () {\n\t    var h = dloc.hash;\n\t    if (h != this.hash) {\n\t      this.hash = h;\n\t      this.onHashChanged();\n\t    }\n\t  },\n\t\n\t  fire: function () {\n\t    if (this.mode === 'modern') {\n\t      this.history === true ? window.onpopstate() : window.onhashchange();\n\t    }\n\t    else {\n\t      this.onHashChanged();\n\t    }\n\t  },\n\t\n\t  init: function (fn, history) {\n\t    var self = this;\n\t    this.history = history;\n\t\n\t    if (!Router.listeners) {\n\t      Router.listeners = [];\n\t    }\n\t\n\t    function onchange(onChangeEvent) {\n\t      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n\t        Router.listeners[i](onChangeEvent);\n\t      }\n\t    }\n\t\n\t    //note IE8 is being counted as 'modern' because it has the hashchange event\n\t    if ('onhashchange' in window && (document.documentMode === undefined\n\t      || document.documentMode > 7)) {\n\t      // At least for now HTML5 history is available for 'modern' browsers only\n\t      if (this.history === true) {\n\t        // There is an old bug in Chrome that causes onpopstate to fire even\n\t        // upon initial page load. Since the handler is run manually in init(),\n\t        // this would cause Chrome to run it twise. Currently the only\n\t        // workaround seems to be to set the handler after the initial page load\n\t        // http://code.google.com/p/chromium/issues/detail?id=63040\n\t        setTimeout(function() {\n\t          window.onpopstate = onchange;\n\t        }, 500);\n\t      }\n\t      else {\n\t        window.onhashchange = onchange;\n\t      }\n\t      this.mode = 'modern';\n\t    }\n\t    else {\n\t      //\n\t      // IE support, based on a concept by Erik Arvidson ...\n\t      //\n\t      var frame = document.createElement('iframe');\n\t      frame.id = 'state-frame';\n\t      frame.style.display = 'none';\n\t      document.body.appendChild(frame);\n\t      this.writeFrame('');\n\t\n\t      if ('onpropertychange' in document && 'attachEvent' in document) {\n\t        document.attachEvent('onpropertychange', function () {\n\t          if (event.propertyName === 'location') {\n\t            self.check();\n\t          }\n\t        });\n\t      }\n\t\n\t      window.setInterval(function () { self.check(); }, 50);\n\t\n\t      this.onHashChanged = onchange;\n\t      this.mode = 'legacy';\n\t    }\n\t\n\t    Router.listeners.push(fn);\n\t\n\t    return this.mode;\n\t  },\n\t\n\t  destroy: function (fn) {\n\t    if (!Router || !Router.listeners) {\n\t      return;\n\t    }\n\t\n\t    var listeners = Router.listeners;\n\t\n\t    for (var i = listeners.length - 1; i >= 0; i--) {\n\t      if (listeners[i] === fn) {\n\t        listeners.splice(i, 1);\n\t      }\n\t    }\n\t  },\n\t\n\t  setHash: function (s) {\n\t    // Mozilla always adds an entry to the history\n\t    if (this.mode === 'legacy') {\n\t      this.writeFrame(s);\n\t    }\n\t\n\t    if (this.history === true) {\n\t      window.history.pushState({}, document.title, s);\n\t      // Fire an onpopstate event manually since pushing does not obviously\n\t      // trigger the pop event.\n\t      this.fire();\n\t    } else {\n\t      dloc.hash = (s[0] === '/') ? s : '/' + s;\n\t    }\n\t    return this;\n\t  },\n\t\n\t  writeFrame: function (s) {\n\t    // IE support...\n\t    var f = document.getElementById('state-frame');\n\t    var d = f.contentDocument || f.contentWindow.document;\n\t    d.open();\n\t    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n\t    d.close();\n\t  },\n\t\n\t  syncHash: function () {\n\t    // IE support...\n\t    var s = this._hash;\n\t    if (s != dloc.hash) {\n\t      dloc.hash = s;\n\t    }\n\t    return this;\n\t  },\n\t\n\t  onHashChanged: function () {}\n\t};\n\t\n\tvar Router = exports.Router = function (routes) {\n\t  if (!(this instanceof Router)) return new Router(routes);\n\t\n\t  this.params   = {};\n\t  this.routes   = {};\n\t  this.methods  = ['on', 'once', 'after', 'before'];\n\t  this.scope    = [];\n\t  this._methods = {};\n\t\n\t  this._insert = this.insert;\n\t  this.insert = this.insertEx;\n\t\n\t  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\t\n\t  this.configure();\n\t  this.mount(routes || {});\n\t};\n\t\n\tRouter.prototype.init = function (r) {\n\t  var self = this\n\t    , routeTo;\n\t  this.handler = function(onChangeEvent) {\n\t    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n\t    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n\t    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n\t  };\n\t\n\t  listener.init(this.handler, this.history);\n\t\n\t  if (this.history === false) {\n\t    if (dlocHashEmpty() && r) {\n\t      dloc.hash = r;\n\t    } else if (!dlocHashEmpty()) {\n\t      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n\t    }\n\t  }\n\t  else {\n\t    if (this.convert_hash_in_init) {\n\t      // Use hash as route\n\t      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n\t      if (routeTo) {\n\t        window.history.replaceState({}, document.title, routeTo);\n\t      }\n\t    }\n\t    else {\n\t      // Use canonical url\n\t      routeTo = this.getPath();\n\t    }\n\t\n\t    // Router has been initialized, but due to the chrome bug it will not\n\t    // yet actually route HTML5 history state changes. Thus, decide if should route.\n\t    if (routeTo || this.run_in_init === true) {\n\t      this.handler();\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tRouter.prototype.explode = function () {\n\t  var v = this.history === true ? this.getPath() : dloc.hash;\n\t  if (v.charAt(1) === '/') { v=v.slice(1) }\n\t  return v.slice(1, v.length).split(\"/\");\n\t};\n\t\n\tRouter.prototype.setRoute = function (i, v, val) {\n\t  var url = this.explode();\n\t\n\t  if (typeof i === 'number' && typeof v === 'string') {\n\t    url[i] = v;\n\t  }\n\t  else if (typeof val === 'string') {\n\t    url.splice(i, v, s);\n\t  }\n\t  else {\n\t    url = [i];\n\t  }\n\t\n\t  listener.setHash(url.join('/'));\n\t  return url;\n\t};\n\t\n\t//\n\t// ### function insertEx(method, path, route, parent)\n\t// #### @method {string} Method to insert the specific `route`.\n\t// #### @path {Array} Parsed path to insert the `route` at.\n\t// #### @route {Array|function} Route handlers to insert.\n\t// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n\t// insert a callback that will only occur once per the matched route.\n\t//\n\tRouter.prototype.insertEx = function(method, path, route, parent) {\n\t  if (method === \"once\") {\n\t    method = \"on\";\n\t    route = function(route) {\n\t      var once = false;\n\t      return function() {\n\t        if (once) return;\n\t        once = true;\n\t        return route.apply(this, arguments);\n\t      };\n\t    }(route);\n\t  }\n\t  return this._insert(method, path, route, parent);\n\t};\n\t\n\tRouter.prototype.getRoute = function (v) {\n\t  var ret = v;\n\t\n\t  if (typeof v === \"number\") {\n\t    ret = this.explode()[v];\n\t  }\n\t  else if (typeof v === \"string\"){\n\t    var h = this.explode();\n\t    ret = h.indexOf(v);\n\t  }\n\t  else {\n\t    ret = this.explode();\n\t  }\n\t\n\t  return ret;\n\t};\n\t\n\tRouter.prototype.destroy = function () {\n\t  listener.destroy(this.handler);\n\t  return this;\n\t};\n\t\n\tRouter.prototype.getPath = function () {\n\t  var path = window.location.pathname;\n\t  if (path.substr(0, 1) !== '/') {\n\t    path = '/' + path;\n\t  }\n\t  return path;\n\t};\n\tfunction _every(arr, iterator) {\n\t  for (var i = 0; i < arr.length; i += 1) {\n\t    if (iterator(arr[i], i, arr) === false) {\n\t      return;\n\t    }\n\t  }\n\t}\n\t\n\tfunction _flatten(arr) {\n\t  var flat = [];\n\t  for (var i = 0, n = arr.length; i < n; i++) {\n\t    flat = flat.concat(arr[i]);\n\t  }\n\t  return flat;\n\t}\n\t\n\tfunction _asyncEverySeries(arr, iterator, callback) {\n\t  if (!arr.length) {\n\t    return callback();\n\t  }\n\t  var completed = 0;\n\t  (function iterate() {\n\t    iterator(arr[completed], function(err) {\n\t      if (err || err === false) {\n\t        callback(err);\n\t        callback = function() {};\n\t      } else {\n\t        completed += 1;\n\t        if (completed === arr.length) {\n\t          callback();\n\t        } else {\n\t          iterate();\n\t        }\n\t      }\n\t    });\n\t  })();\n\t}\n\t\n\tfunction paramifyString(str, params, mod) {\n\t  mod = str;\n\t  for (var param in params) {\n\t    if (params.hasOwnProperty(param)) {\n\t      mod = params[param](str);\n\t      if (mod !== str) {\n\t        break;\n\t      }\n\t    }\n\t  }\n\t  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n\t}\n\t\n\tfunction regifyString(str, params) {\n\t  var matches, last = 0, out = \"\";\n\t  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n\t    last = matches.index + matches[0].length;\n\t    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n\t    out += str.substr(0, matches.index) + matches[0];\n\t  }\n\t  str = out += str.substr(last);\n\t  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n\t  if (captures) {\n\t    length = captures.length;\n\t    for (var i = 0; i < length; i++) {\n\t      capture = captures[i];\n\t      if (capture.slice(0, 2) === \"::\") {\n\t        str = capture.slice(1);\n\t      } else {\n\t        str = str.replace(capture, paramifyString(capture, params));\n\t      }\n\t    }\n\t  }\n\t  return str;\n\t}\n\t\n\tfunction terminator(routes, delimiter, start, stop) {\n\t  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n\t  for (i = 0; i < routes.length; i++) {\n\t    var chunk = routes[i];\n\t    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n\t      left = chunk.indexOf(start, last);\n\t      right = chunk.indexOf(stop, last);\n\t      if (~left && !~right || !~left && ~right) {\n\t        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n\t        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n\t      }\n\t      last = (right > left ? right : left) + 1;\n\t      i = 0;\n\t    } else {\n\t      last = 0;\n\t    }\n\t  }\n\t  return routes;\n\t}\n\t\n\tvar QUERY_SEPARATOR = /\\?.*/;\n\t\n\tRouter.prototype.configure = function(options) {\n\t  options = options || {};\n\t  for (var i = 0; i < this.methods.length; i++) {\n\t    this._methods[this.methods[i]] = true;\n\t  }\n\t  this.recurse = options.recurse || this.recurse || false;\n\t  this.async = options.async || false;\n\t  this.delimiter = options.delimiter || \"/\";\n\t  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n\t  this.notfound = options.notfound;\n\t  this.resource = options.resource;\n\t  this.history = options.html5history && this.historySupport || false;\n\t  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n\t  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n\t  this.every = {\n\t    after: options.after || null,\n\t    before: options.before || null,\n\t    on: options.on || null\n\t  };\n\t  return this;\n\t};\n\t\n\tRouter.prototype.param = function(token, matcher) {\n\t  if (token[0] !== \":\") {\n\t    token = \":\" + token;\n\t  }\n\t  var compiled = new RegExp(token, \"g\");\n\t  this.params[token] = function(str) {\n\t    return str.replace(compiled, matcher.source || matcher);\n\t  };\n\t  return this;\n\t};\n\t\n\tRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n\t  var self = this;\n\t  if (!route && typeof path == \"function\") {\n\t    route = path;\n\t    path = method;\n\t    method = \"on\";\n\t  }\n\t  if (Array.isArray(path)) {\n\t    return path.forEach(function(p) {\n\t      self.on(method, p, route);\n\t    });\n\t  }\n\t  if (path.source) {\n\t    path = path.source.replace(/\\\\\\//ig, \"/\");\n\t  }\n\t  if (Array.isArray(method)) {\n\t    return method.forEach(function(m) {\n\t      self.on(m.toLowerCase(), path, route);\n\t    });\n\t  }\n\t  path = path.split(new RegExp(this.delimiter));\n\t  path = terminator(path, this.delimiter);\n\t  this.insert(method, this.scope.concat(path), route);\n\t};\n\t\n\tRouter.prototype.path = function(path, routesFn) {\n\t  var self = this, length = this.scope.length;\n\t  if (path.source) {\n\t    path = path.source.replace(/\\\\\\//ig, \"/\");\n\t  }\n\t  path = path.split(new RegExp(this.delimiter));\n\t  path = terminator(path, this.delimiter);\n\t  this.scope = this.scope.concat(path);\n\t  routesFn.call(this, this);\n\t  this.scope.splice(length, path.length);\n\t};\n\t\n\tRouter.prototype.dispatch = function(method, path, callback) {\n\t  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n\t  this._invoked = true;\n\t  if (!fns || fns.length === 0) {\n\t    this.last = [];\n\t    if (typeof this.notfound === \"function\") {\n\t      this.invoke([ this.notfound ], {\n\t        method: method,\n\t        path: path\n\t      }, callback);\n\t    }\n\t    return false;\n\t  }\n\t  if (this.recurse === \"forward\") {\n\t    fns = fns.reverse();\n\t  }\n\t  function updateAndInvoke() {\n\t    self.last = fns.after;\n\t    self.invoke(self.runlist(fns), self, callback);\n\t  }\n\t  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n\t  if (after && after.length > 0 && invoked) {\n\t    if (this.async) {\n\t      this.invoke(after, this, updateAndInvoke);\n\t    } else {\n\t      this.invoke(after, this);\n\t      updateAndInvoke();\n\t    }\n\t    return true;\n\t  }\n\t  updateAndInvoke();\n\t  return true;\n\t};\n\t\n\tRouter.prototype.invoke = function(fns, thisArg, callback) {\n\t  var self = this;\n\t  var apply;\n\t  if (this.async) {\n\t    apply = function(fn, next) {\n\t      if (Array.isArray(fn)) {\n\t        return _asyncEverySeries(fn, apply, next);\n\t      } else if (typeof fn == \"function\") {\n\t        fn.apply(thisArg, (fns.captures || []).concat(next));\n\t      }\n\t    };\n\t    _asyncEverySeries(fns, apply, function() {\n\t      if (callback) {\n\t        callback.apply(thisArg, arguments);\n\t      }\n\t    });\n\t  } else {\n\t    apply = function(fn) {\n\t      if (Array.isArray(fn)) {\n\t        return _every(fn, apply);\n\t      } else if (typeof fn === \"function\") {\n\t        return fn.apply(thisArg, fns.captures || []);\n\t      } else if (typeof fn === \"string\" && self.resource) {\n\t        self.resource[fn].apply(thisArg, fns.captures || []);\n\t      }\n\t    };\n\t    _every(fns, apply);\n\t  }\n\t};\n\t\n\tRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n\t  var fns = [], current, exact, match, next, that;\n\t  function filterRoutes(routes) {\n\t    if (!filter) {\n\t      return routes;\n\t    }\n\t    function deepCopy(source) {\n\t      var result = [];\n\t      for (var i = 0; i < source.length; i++) {\n\t        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n\t      }\n\t      return result;\n\t    }\n\t    function applyFilter(fns) {\n\t      for (var i = fns.length - 1; i >= 0; i--) {\n\t        if (Array.isArray(fns[i])) {\n\t          applyFilter(fns[i]);\n\t          if (fns[i].length === 0) {\n\t            fns.splice(i, 1);\n\t          }\n\t        } else {\n\t          if (!filter(fns[i])) {\n\t            fns.splice(i, 1);\n\t          }\n\t        }\n\t      }\n\t    }\n\t    var newRoutes = deepCopy(routes);\n\t    newRoutes.matched = routes.matched;\n\t    newRoutes.captures = routes.captures;\n\t    newRoutes.after = routes.after.filter(filter);\n\t    applyFilter(newRoutes);\n\t    return newRoutes;\n\t  }\n\t  if (path === this.delimiter && routes[method]) {\n\t    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n\t    next.after = [ routes.after ].filter(Boolean);\n\t    next.matched = true;\n\t    next.captures = [];\n\t    return filterRoutes(next);\n\t  }\n\t  for (var r in routes) {\n\t    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n\t      current = exact = regexp + this.delimiter + r;\n\t      if (!this.strict) {\n\t        exact += \"[\" + this.delimiter + \"]?\";\n\t      }\n\t      match = path.match(new RegExp(\"^\" + exact));\n\t      if (!match) {\n\t        continue;\n\t      }\n\t      if (match[0] && match[0] == path && routes[r][method]) {\n\t        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n\t        next.after = [ routes[r].after ].filter(Boolean);\n\t        next.matched = true;\n\t        next.captures = match.slice(1);\n\t        if (this.recurse && routes === this.routes) {\n\t          next.push([ routes.before, routes.on ].filter(Boolean));\n\t          next.after = next.after.concat([ routes.after ].filter(Boolean));\n\t        }\n\t        return filterRoutes(next);\n\t      }\n\t      next = this.traverse(method, path, routes[r], current);\n\t      if (next.matched) {\n\t        if (next.length > 0) {\n\t          fns = fns.concat(next);\n\t        }\n\t        if (this.recurse) {\n\t          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n\t          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n\t          if (routes === this.routes) {\n\t            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n\t            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n\t          }\n\t        }\n\t        fns.matched = true;\n\t        fns.captures = next.captures;\n\t        fns.after = next.after;\n\t        return filterRoutes(fns);\n\t      }\n\t    }\n\t  }\n\t  return false;\n\t};\n\t\n\tRouter.prototype.insert = function(method, path, route, parent) {\n\t  var methodType, parentType, isArray, nested, part;\n\t  path = path.filter(function(p) {\n\t    return p && p.length > 0;\n\t  });\n\t  parent = parent || this.routes;\n\t  part = path.shift();\n\t  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n\t    part = regifyString(part, this.params);\n\t  }\n\t  if (path.length > 0) {\n\t    parent[part] = parent[part] || {};\n\t    return this.insert(method, path, route, parent[part]);\n\t  }\n\t  if (!part && !path.length && parent === this.routes) {\n\t    methodType = typeof parent[method];\n\t    switch (methodType) {\n\t     case \"function\":\n\t      parent[method] = [ parent[method], route ];\n\t      return;\n\t     case \"object\":\n\t      parent[method].push(route);\n\t      return;\n\t     case \"undefined\":\n\t      parent[method] = route;\n\t      return;\n\t    }\n\t    return;\n\t  }\n\t  parentType = typeof parent[part];\n\t  isArray = Array.isArray(parent[part]);\n\t  if (parent[part] && !isArray && parentType == \"object\") {\n\t    methodType = typeof parent[part][method];\n\t    switch (methodType) {\n\t     case \"function\":\n\t      parent[part][method] = [ parent[part][method], route ];\n\t      return;\n\t     case \"object\":\n\t      parent[part][method].push(route);\n\t      return;\n\t     case \"undefined\":\n\t      parent[part][method] = route;\n\t      return;\n\t    }\n\t  } else if (parentType == \"undefined\") {\n\t    nested = {};\n\t    nested[method] = route;\n\t    parent[part] = nested;\n\t    return;\n\t  }\n\t  throw new Error(\"Invalid route context: \" + parentType);\n\t};\n\t\n\t\n\t\n\tRouter.prototype.extend = function(methods) {\n\t  var self = this, len = methods.length, i;\n\t  function extend(method) {\n\t    self._methods[method] = true;\n\t    self[method] = function() {\n\t      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n\t      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n\t    };\n\t  }\n\t  for (i = 0; i < len; i++) {\n\t    extend(methods[i]);\n\t  }\n\t};\n\t\n\tRouter.prototype.runlist = function(fns) {\n\t  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n\t  if (this.every && this.every.on) {\n\t    runlist.push(this.every.on);\n\t  }\n\t  runlist.captures = fns.captures;\n\t  runlist.source = fns.source;\n\t  return runlist;\n\t};\n\t\n\tRouter.prototype.mount = function(routes, path) {\n\t  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n\t    return;\n\t  }\n\t  var self = this;\n\t  path = path || [];\n\t  if (!Array.isArray(path)) {\n\t    path = path.split(self.delimiter);\n\t  }\n\t  function insertOrMount(route, local) {\n\t    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n\t    if (isRoute) {\n\t      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n\t      parts.shift();\n\t    }\n\t    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n\t      local = local.concat(parts);\n\t      self.mount(routes[route], local);\n\t      return;\n\t    }\n\t    if (isRoute) {\n\t      local = local.concat(rename.split(self.delimiter));\n\t      local = terminator(local, self.delimiter);\n\t    }\n\t    self.insert(event, local, routes[route]);\n\t  }\n\t  for (var route in routes) {\n\t    if (routes.hasOwnProperty(route)) {\n\t      insertOrMount(route, path.slice(0));\n\t    }\n\t  }\n\t};\n\t\n\t\n\t\n\t}( true ? exports : window));\n\n/***/ }\n\n/******/ });\n\n\n/** WEBPACK FOOTER **\n ** main.bundle.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 25ceab3b366187455a51\n **/","import { Router } from 'director';\n\nconst routes = {\n    '/classic': function() {\n        console.log('classic');\n    },\n    '/filebrowser': function() {\n        console.log('filebrowser');\n    }\n};\n\nconst router = Router(routes);\nrouter.init();\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","\n\n//\n// Generated on Tue Dec 16 2014 12:13:47 GMT+0100 (CET) by Charlie Robbins, Paolo Fragomeni & the Contributors (Using Codesurgeon).\n// Version 1.2.6\n//\n\n(function (exports) {\n\n/*\n * browser.js: Browser specific functionality for director.\n *\n * (C) 2011, Charlie Robbins, Paolo Fragomeni, & the Contributors.\n * MIT LICENSE\n *\n */\n\nvar dloc = document.location;\n\nfunction dlocHashEmpty() {\n  // Non-IE browsers return '' when the address bar shows '#'; Director's logic\n  // assumes both mean empty.\n  return dloc.hash === '' || dloc.hash === '#';\n}\n\nvar listener = {\n  mode: 'modern',\n  hash: dloc.hash,\n  history: false,\n\n  check: function () {\n    var h = dloc.hash;\n    if (h != this.hash) {\n      this.hash = h;\n      this.onHashChanged();\n    }\n  },\n\n  fire: function () {\n    if (this.mode === 'modern') {\n      this.history === true ? window.onpopstate() : window.onhashchange();\n    }\n    else {\n      this.onHashChanged();\n    }\n  },\n\n  init: function (fn, history) {\n    var self = this;\n    this.history = history;\n\n    if (!Router.listeners) {\n      Router.listeners = [];\n    }\n\n    function onchange(onChangeEvent) {\n      for (var i = 0, l = Router.listeners.length; i < l; i++) {\n        Router.listeners[i](onChangeEvent);\n      }\n    }\n\n    //note IE8 is being counted as 'modern' because it has the hashchange event\n    if ('onhashchange' in window && (document.documentMode === undefined\n      || document.documentMode > 7)) {\n      // At least for now HTML5 history is available for 'modern' browsers only\n      if (this.history === true) {\n        // There is an old bug in Chrome that causes onpopstate to fire even\n        // upon initial page load. Since the handler is run manually in init(),\n        // this would cause Chrome to run it twise. Currently the only\n        // workaround seems to be to set the handler after the initial page load\n        // http://code.google.com/p/chromium/issues/detail?id=63040\n        setTimeout(function() {\n          window.onpopstate = onchange;\n        }, 500);\n      }\n      else {\n        window.onhashchange = onchange;\n      }\n      this.mode = 'modern';\n    }\n    else {\n      //\n      // IE support, based on a concept by Erik Arvidson ...\n      //\n      var frame = document.createElement('iframe');\n      frame.id = 'state-frame';\n      frame.style.display = 'none';\n      document.body.appendChild(frame);\n      this.writeFrame('');\n\n      if ('onpropertychange' in document && 'attachEvent' in document) {\n        document.attachEvent('onpropertychange', function () {\n          if (event.propertyName === 'location') {\n            self.check();\n          }\n        });\n      }\n\n      window.setInterval(function () { self.check(); }, 50);\n\n      this.onHashChanged = onchange;\n      this.mode = 'legacy';\n    }\n\n    Router.listeners.push(fn);\n\n    return this.mode;\n  },\n\n  destroy: function (fn) {\n    if (!Router || !Router.listeners) {\n      return;\n    }\n\n    var listeners = Router.listeners;\n\n    for (var i = listeners.length - 1; i >= 0; i--) {\n      if (listeners[i] === fn) {\n        listeners.splice(i, 1);\n      }\n    }\n  },\n\n  setHash: function (s) {\n    // Mozilla always adds an entry to the history\n    if (this.mode === 'legacy') {\n      this.writeFrame(s);\n    }\n\n    if (this.history === true) {\n      window.history.pushState({}, document.title, s);\n      // Fire an onpopstate event manually since pushing does not obviously\n      // trigger the pop event.\n      this.fire();\n    } else {\n      dloc.hash = (s[0] === '/') ? s : '/' + s;\n    }\n    return this;\n  },\n\n  writeFrame: function (s) {\n    // IE support...\n    var f = document.getElementById('state-frame');\n    var d = f.contentDocument || f.contentWindow.document;\n    d.open();\n    d.write(\"<script>_hash = '\" + s + \"'; onload = parent.listener.syncHash;<script>\");\n    d.close();\n  },\n\n  syncHash: function () {\n    // IE support...\n    var s = this._hash;\n    if (s != dloc.hash) {\n      dloc.hash = s;\n    }\n    return this;\n  },\n\n  onHashChanged: function () {}\n};\n\nvar Router = exports.Router = function (routes) {\n  if (!(this instanceof Router)) return new Router(routes);\n\n  this.params   = {};\n  this.routes   = {};\n  this.methods  = ['on', 'once', 'after', 'before'];\n  this.scope    = [];\n  this._methods = {};\n\n  this._insert = this.insert;\n  this.insert = this.insertEx;\n\n  this.historySupport = (window.history != null ? window.history.pushState : null) != null\n\n  this.configure();\n  this.mount(routes || {});\n};\n\nRouter.prototype.init = function (r) {\n  var self = this\n    , routeTo;\n  this.handler = function(onChangeEvent) {\n    var newURL = onChangeEvent && onChangeEvent.newURL || window.location.hash;\n    var url = self.history === true ? self.getPath() : newURL.replace(/.*#/, '');\n    self.dispatch('on', url.charAt(0) === '/' ? url : '/' + url);\n  };\n\n  listener.init(this.handler, this.history);\n\n  if (this.history === false) {\n    if (dlocHashEmpty() && r) {\n      dloc.hash = r;\n    } else if (!dlocHashEmpty()) {\n      self.dispatch('on', '/' + dloc.hash.replace(/^(#\\/|#|\\/)/, ''));\n    }\n  }\n  else {\n    if (this.convert_hash_in_init) {\n      // Use hash as route\n      routeTo = dlocHashEmpty() && r ? r : !dlocHashEmpty() ? dloc.hash.replace(/^#/, '') : null;\n      if (routeTo) {\n        window.history.replaceState({}, document.title, routeTo);\n      }\n    }\n    else {\n      // Use canonical url\n      routeTo = this.getPath();\n    }\n\n    // Router has been initialized, but due to the chrome bug it will not\n    // yet actually route HTML5 history state changes. Thus, decide if should route.\n    if (routeTo || this.run_in_init === true) {\n      this.handler();\n    }\n  }\n\n  return this;\n};\n\nRouter.prototype.explode = function () {\n  var v = this.history === true ? this.getPath() : dloc.hash;\n  if (v.charAt(1) === '/') { v=v.slice(1) }\n  return v.slice(1, v.length).split(\"/\");\n};\n\nRouter.prototype.setRoute = function (i, v, val) {\n  var url = this.explode();\n\n  if (typeof i === 'number' && typeof v === 'string') {\n    url[i] = v;\n  }\n  else if (typeof val === 'string') {\n    url.splice(i, v, s);\n  }\n  else {\n    url = [i];\n  }\n\n  listener.setHash(url.join('/'));\n  return url;\n};\n\n//\n// ### function insertEx(method, path, route, parent)\n// #### @method {string} Method to insert the specific `route`.\n// #### @path {Array} Parsed path to insert the `route` at.\n// #### @route {Array|function} Route handlers to insert.\n// #### @parent {Object} **Optional** Parent \"routes\" to insert into.\n// insert a callback that will only occur once per the matched route.\n//\nRouter.prototype.insertEx = function(method, path, route, parent) {\n  if (method === \"once\") {\n    method = \"on\";\n    route = function(route) {\n      var once = false;\n      return function() {\n        if (once) return;\n        once = true;\n        return route.apply(this, arguments);\n      };\n    }(route);\n  }\n  return this._insert(method, path, route, parent);\n};\n\nRouter.prototype.getRoute = function (v) {\n  var ret = v;\n\n  if (typeof v === \"number\") {\n    ret = this.explode()[v];\n  }\n  else if (typeof v === \"string\"){\n    var h = this.explode();\n    ret = h.indexOf(v);\n  }\n  else {\n    ret = this.explode();\n  }\n\n  return ret;\n};\n\nRouter.prototype.destroy = function () {\n  listener.destroy(this.handler);\n  return this;\n};\n\nRouter.prototype.getPath = function () {\n  var path = window.location.pathname;\n  if (path.substr(0, 1) !== '/') {\n    path = '/' + path;\n  }\n  return path;\n};\nfunction _every(arr, iterator) {\n  for (var i = 0; i < arr.length; i += 1) {\n    if (iterator(arr[i], i, arr) === false) {\n      return;\n    }\n  }\n}\n\nfunction _flatten(arr) {\n  var flat = [];\n  for (var i = 0, n = arr.length; i < n; i++) {\n    flat = flat.concat(arr[i]);\n  }\n  return flat;\n}\n\nfunction _asyncEverySeries(arr, iterator, callback) {\n  if (!arr.length) {\n    return callback();\n  }\n  var completed = 0;\n  (function iterate() {\n    iterator(arr[completed], function(err) {\n      if (err || err === false) {\n        callback(err);\n        callback = function() {};\n      } else {\n        completed += 1;\n        if (completed === arr.length) {\n          callback();\n        } else {\n          iterate();\n        }\n      }\n    });\n  })();\n}\n\nfunction paramifyString(str, params, mod) {\n  mod = str;\n  for (var param in params) {\n    if (params.hasOwnProperty(param)) {\n      mod = params[param](str);\n      if (mod !== str) {\n        break;\n      }\n    }\n  }\n  return mod === str ? \"([._a-zA-Z0-9-%()]+)\" : mod;\n}\n\nfunction regifyString(str, params) {\n  var matches, last = 0, out = \"\";\n  while (matches = str.substr(last).match(/[^\\w\\d\\- %@&]*\\*[^\\w\\d\\- %@&]*/)) {\n    last = matches.index + matches[0].length;\n    matches[0] = matches[0].replace(/^\\*/, \"([_.()!\\\\ %@&a-zA-Z0-9-]+)\");\n    out += str.substr(0, matches.index) + matches[0];\n  }\n  str = out += str.substr(last);\n  var captures = str.match(/:([^\\/]+)/ig), capture, length;\n  if (captures) {\n    length = captures.length;\n    for (var i = 0; i < length; i++) {\n      capture = captures[i];\n      if (capture.slice(0, 2) === \"::\") {\n        str = capture.slice(1);\n      } else {\n        str = str.replace(capture, paramifyString(capture, params));\n      }\n    }\n  }\n  return str;\n}\n\nfunction terminator(routes, delimiter, start, stop) {\n  var last = 0, left = 0, right = 0, start = (start || \"(\").toString(), stop = (stop || \")\").toString(), i;\n  for (i = 0; i < routes.length; i++) {\n    var chunk = routes[i];\n    if (chunk.indexOf(start, last) > chunk.indexOf(stop, last) || ~chunk.indexOf(start, last) && !~chunk.indexOf(stop, last) || !~chunk.indexOf(start, last) && ~chunk.indexOf(stop, last)) {\n      left = chunk.indexOf(start, last);\n      right = chunk.indexOf(stop, last);\n      if (~left && !~right || !~left && ~right) {\n        var tmp = routes.slice(0, (i || 1) + 1).join(delimiter);\n        routes = [ tmp ].concat(routes.slice((i || 1) + 1));\n      }\n      last = (right > left ? right : left) + 1;\n      i = 0;\n    } else {\n      last = 0;\n    }\n  }\n  return routes;\n}\n\nvar QUERY_SEPARATOR = /\\?.*/;\n\nRouter.prototype.configure = function(options) {\n  options = options || {};\n  for (var i = 0; i < this.methods.length; i++) {\n    this._methods[this.methods[i]] = true;\n  }\n  this.recurse = options.recurse || this.recurse || false;\n  this.async = options.async || false;\n  this.delimiter = options.delimiter || \"/\";\n  this.strict = typeof options.strict === \"undefined\" ? true : options.strict;\n  this.notfound = options.notfound;\n  this.resource = options.resource;\n  this.history = options.html5history && this.historySupport || false;\n  this.run_in_init = this.history === true && options.run_handler_in_init !== false;\n  this.convert_hash_in_init = this.history === true && options.convert_hash_in_init !== false;\n  this.every = {\n    after: options.after || null,\n    before: options.before || null,\n    on: options.on || null\n  };\n  return this;\n};\n\nRouter.prototype.param = function(token, matcher) {\n  if (token[0] !== \":\") {\n    token = \":\" + token;\n  }\n  var compiled = new RegExp(token, \"g\");\n  this.params[token] = function(str) {\n    return str.replace(compiled, matcher.source || matcher);\n  };\n  return this;\n};\n\nRouter.prototype.on = Router.prototype.route = function(method, path, route) {\n  var self = this;\n  if (!route && typeof path == \"function\") {\n    route = path;\n    path = method;\n    method = \"on\";\n  }\n  if (Array.isArray(path)) {\n    return path.forEach(function(p) {\n      self.on(method, p, route);\n    });\n  }\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  if (Array.isArray(method)) {\n    return method.forEach(function(m) {\n      self.on(m.toLowerCase(), path, route);\n    });\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.insert(method, this.scope.concat(path), route);\n};\n\nRouter.prototype.path = function(path, routesFn) {\n  var self = this, length = this.scope.length;\n  if (path.source) {\n    path = path.source.replace(/\\\\\\//ig, \"/\");\n  }\n  path = path.split(new RegExp(this.delimiter));\n  path = terminator(path, this.delimiter);\n  this.scope = this.scope.concat(path);\n  routesFn.call(this, this);\n  this.scope.splice(length, path.length);\n};\n\nRouter.prototype.dispatch = function(method, path, callback) {\n  var self = this, fns = this.traverse(method, path.replace(QUERY_SEPARATOR, \"\"), this.routes, \"\"), invoked = this._invoked, after;\n  this._invoked = true;\n  if (!fns || fns.length === 0) {\n    this.last = [];\n    if (typeof this.notfound === \"function\") {\n      this.invoke([ this.notfound ], {\n        method: method,\n        path: path\n      }, callback);\n    }\n    return false;\n  }\n  if (this.recurse === \"forward\") {\n    fns = fns.reverse();\n  }\n  function updateAndInvoke() {\n    self.last = fns.after;\n    self.invoke(self.runlist(fns), self, callback);\n  }\n  after = this.every && this.every.after ? [ this.every.after ].concat(this.last) : [ this.last ];\n  if (after && after.length > 0 && invoked) {\n    if (this.async) {\n      this.invoke(after, this, updateAndInvoke);\n    } else {\n      this.invoke(after, this);\n      updateAndInvoke();\n    }\n    return true;\n  }\n  updateAndInvoke();\n  return true;\n};\n\nRouter.prototype.invoke = function(fns, thisArg, callback) {\n  var self = this;\n  var apply;\n  if (this.async) {\n    apply = function(fn, next) {\n      if (Array.isArray(fn)) {\n        return _asyncEverySeries(fn, apply, next);\n      } else if (typeof fn == \"function\") {\n        fn.apply(thisArg, (fns.captures || []).concat(next));\n      }\n    };\n    _asyncEverySeries(fns, apply, function() {\n      if (callback) {\n        callback.apply(thisArg, arguments);\n      }\n    });\n  } else {\n    apply = function(fn) {\n      if (Array.isArray(fn)) {\n        return _every(fn, apply);\n      } else if (typeof fn === \"function\") {\n        return fn.apply(thisArg, fns.captures || []);\n      } else if (typeof fn === \"string\" && self.resource) {\n        self.resource[fn].apply(thisArg, fns.captures || []);\n      }\n    };\n    _every(fns, apply);\n  }\n};\n\nRouter.prototype.traverse = function(method, path, routes, regexp, filter) {\n  var fns = [], current, exact, match, next, that;\n  function filterRoutes(routes) {\n    if (!filter) {\n      return routes;\n    }\n    function deepCopy(source) {\n      var result = [];\n      for (var i = 0; i < source.length; i++) {\n        result[i] = Array.isArray(source[i]) ? deepCopy(source[i]) : source[i];\n      }\n      return result;\n    }\n    function applyFilter(fns) {\n      for (var i = fns.length - 1; i >= 0; i--) {\n        if (Array.isArray(fns[i])) {\n          applyFilter(fns[i]);\n          if (fns[i].length === 0) {\n            fns.splice(i, 1);\n          }\n        } else {\n          if (!filter(fns[i])) {\n            fns.splice(i, 1);\n          }\n        }\n      }\n    }\n    var newRoutes = deepCopy(routes);\n    newRoutes.matched = routes.matched;\n    newRoutes.captures = routes.captures;\n    newRoutes.after = routes.after.filter(filter);\n    applyFilter(newRoutes);\n    return newRoutes;\n  }\n  if (path === this.delimiter && routes[method]) {\n    next = [ [ routes.before, routes[method] ].filter(Boolean) ];\n    next.after = [ routes.after ].filter(Boolean);\n    next.matched = true;\n    next.captures = [];\n    return filterRoutes(next);\n  }\n  for (var r in routes) {\n    if (routes.hasOwnProperty(r) && (!this._methods[r] || this._methods[r] && typeof routes[r] === \"object\" && !Array.isArray(routes[r]))) {\n      current = exact = regexp + this.delimiter + r;\n      if (!this.strict) {\n        exact += \"[\" + this.delimiter + \"]?\";\n      }\n      match = path.match(new RegExp(\"^\" + exact));\n      if (!match) {\n        continue;\n      }\n      if (match[0] && match[0] == path && routes[r][method]) {\n        next = [ [ routes[r].before, routes[r][method] ].filter(Boolean) ];\n        next.after = [ routes[r].after ].filter(Boolean);\n        next.matched = true;\n        next.captures = match.slice(1);\n        if (this.recurse && routes === this.routes) {\n          next.push([ routes.before, routes.on ].filter(Boolean));\n          next.after = next.after.concat([ routes.after ].filter(Boolean));\n        }\n        return filterRoutes(next);\n      }\n      next = this.traverse(method, path, routes[r], current);\n      if (next.matched) {\n        if (next.length > 0) {\n          fns = fns.concat(next);\n        }\n        if (this.recurse) {\n          fns.push([ routes[r].before, routes[r].on ].filter(Boolean));\n          next.after = next.after.concat([ routes[r].after ].filter(Boolean));\n          if (routes === this.routes) {\n            fns.push([ routes[\"before\"], routes[\"on\"] ].filter(Boolean));\n            next.after = next.after.concat([ routes[\"after\"] ].filter(Boolean));\n          }\n        }\n        fns.matched = true;\n        fns.captures = next.captures;\n        fns.after = next.after;\n        return filterRoutes(fns);\n      }\n    }\n  }\n  return false;\n};\n\nRouter.prototype.insert = function(method, path, route, parent) {\n  var methodType, parentType, isArray, nested, part;\n  path = path.filter(function(p) {\n    return p && p.length > 0;\n  });\n  parent = parent || this.routes;\n  part = path.shift();\n  if (/\\:|\\*/.test(part) && !/\\\\d|\\\\w/.test(part)) {\n    part = regifyString(part, this.params);\n  }\n  if (path.length > 0) {\n    parent[part] = parent[part] || {};\n    return this.insert(method, path, route, parent[part]);\n  }\n  if (!part && !path.length && parent === this.routes) {\n    methodType = typeof parent[method];\n    switch (methodType) {\n     case \"function\":\n      parent[method] = [ parent[method], route ];\n      return;\n     case \"object\":\n      parent[method].push(route);\n      return;\n     case \"undefined\":\n      parent[method] = route;\n      return;\n    }\n    return;\n  }\n  parentType = typeof parent[part];\n  isArray = Array.isArray(parent[part]);\n  if (parent[part] && !isArray && parentType == \"object\") {\n    methodType = typeof parent[part][method];\n    switch (methodType) {\n     case \"function\":\n      parent[part][method] = [ parent[part][method], route ];\n      return;\n     case \"object\":\n      parent[part][method].push(route);\n      return;\n     case \"undefined\":\n      parent[part][method] = route;\n      return;\n    }\n  } else if (parentType == \"undefined\") {\n    nested = {};\n    nested[method] = route;\n    parent[part] = nested;\n    return;\n  }\n  throw new Error(\"Invalid route context: \" + parentType);\n};\n\n\n\nRouter.prototype.extend = function(methods) {\n  var self = this, len = methods.length, i;\n  function extend(method) {\n    self._methods[method] = true;\n    self[method] = function() {\n      var extra = arguments.length === 1 ? [ method, \"\" ] : [ method ];\n      self.on.apply(self, extra.concat(Array.prototype.slice.call(arguments)));\n    };\n  }\n  for (i = 0; i < len; i++) {\n    extend(methods[i]);\n  }\n};\n\nRouter.prototype.runlist = function(fns) {\n  var runlist = this.every && this.every.before ? [ this.every.before ].concat(_flatten(fns)) : _flatten(fns);\n  if (this.every && this.every.on) {\n    runlist.push(this.every.on);\n  }\n  runlist.captures = fns.captures;\n  runlist.source = fns.source;\n  return runlist;\n};\n\nRouter.prototype.mount = function(routes, path) {\n  if (!routes || typeof routes !== \"object\" || Array.isArray(routes)) {\n    return;\n  }\n  var self = this;\n  path = path || [];\n  if (!Array.isArray(path)) {\n    path = path.split(self.delimiter);\n  }\n  function insertOrMount(route, local) {\n    var rename = route, parts = route.split(self.delimiter), routeType = typeof routes[route], isRoute = parts[0] === \"\" || !self._methods[parts[0]], event = isRoute ? \"on\" : rename;\n    if (isRoute) {\n      rename = rename.slice((rename.match(new RegExp(\"^\" + self.delimiter)) || [ \"\" ])[0].length);\n      parts.shift();\n    }\n    if (isRoute && routeType === \"object\" && !Array.isArray(routes[route])) {\n      local = local.concat(parts);\n      self.mount(routes[route], local);\n      return;\n    }\n    if (isRoute) {\n      local = local.concat(rename.split(self.delimiter));\n      local = terminator(local, self.delimiter);\n    }\n    self.insert(event, local, routes[route]);\n  }\n  for (var route in routes) {\n    if (routes.hasOwnProperty(route)) {\n      insertOrMount(route, path.slice(0));\n    }\n  }\n};\n\n\n\n}(typeof exports === \"object\" ? exports : window));\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/director/build/director.js\n ** module id = 30\n ** module chunks = 2\n **/"],"sourceRoot":""}